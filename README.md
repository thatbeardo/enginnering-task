A RESTful API that allows users to search the underlying store of cars based on certain search parameters. The API is built using Go Lang. The code is bifurcated into 4 main areas - domain, usecases, interfaces, and infrastructure.

## Domain
Domain encapsulates the core entities of the application. In this case, since we are dealing with Cars, this becomes our core entity. Any business logic pertaining to cars must be defined here. Let's say for example in the future we can to add provisions to the API to add and remove cars. And while doing so, certain business logic needs to be accomplished. For example Rodo doesn't allow cars older than 25 years. Since this is a pure business logic it must reside in the domain layer. A method to AddCars will be added and this logic will be implemented within that method. Domain is highly business specific while application agnostic. It doesn't care what happens outside.

## Usecases
A level above the domain is the usecases layer. Usecases encapsulate application spefic operations that we wish to execute against a business entity. In the example problem statement, we want to perform a search. It becomes crucial to see the search as a resource in terms of REST and map it to a usecase. Search becomes the operation we want to carry out.
Usecases in contrast to domains are both application specific and business specific. Any action that we want to perform on our domain entities passes through usecases. The search operation is a perfect example for a usecase. While it does not modify cars it needs a source of cars to achieve it's goals. In a way it relies on the business logic as well as on what the application does (Deals with cars).

## Interfaces
As the name suggests this layer is responsible to interact with everything outside our application. It can be a database, a call over HTTP/gRPC etc. it can also be a cli application where the call is made using command line arguments. The interface layer manages this boundary and is responsible for translating outside requests into a language that our application can understand. In this case we are making use HTTP calls, decoding the request and serving the end user with search results. It the part of our application that deals with all external agencies. Interfaces are business agnostic - they don't care much about the business logic. At the same time they are very application specific. Depeding on what flavor of external stimulus we are interested in, our interface layer will change.

## Infrastructure
This part of the code is low level implementation details. Although this example doesn't have a database if we were to have a database such as postgres or mySQL, this is where we would place our code. It contians the low level instructions to store and retrieve data. A good test to consider is to make sure that we can swap out databases without changing a single line in usecases or domain. Interfaces by virtue is highly decoupled but if usecases or domains don't finch if databases are swapped out then we have built a very decoupled system.
As an example the infrastructure layer in this project only has a custom logger. The custom loggers implements the interface defined in usecases and hence can be injected from main at runtime. Something similar would happen if we had a database.
